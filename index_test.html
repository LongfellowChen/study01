<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wild World Game Demo with Maze</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #debug {
            position: absolute;
            top: 45px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            z-index: 100;
        }
        #joystick-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            z-index: 100;
            touch-action: none;
        }
        #joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        #attack-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background-color: red;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            z-index: 100;
        }
        #camera-buttons {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
        }
        #camera-buttons button {
            padding: 8px 12px;
            margin: 0 5px;
            font-size: 14px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #camera-buttons button:hover {
            background-color: #367C39;
        }
    </style>
</head>
<body>
    <div id="camera-buttons">
        <button data-camera="perspective">(1)</button>
        <button data-camera="firstPerson">(2)</button>
        <button data-camera="topDown">(3)</button>
    </div>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>
    <button id="attack-button">Attack</button>
    <div id="debug"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@v0.174.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.174.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        const debugPhysics = false;

        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

        const ext_resource_url = 'https://cdn.jsdelivr.net/gh/LongfellowChen/study01@master';
        const textureLoader = new THREE.TextureLoader();

        function createDebugMeshFromCannonShape(body, shape) {
            let debugMesh;
            if (shape instanceof CANNON.Box) {
                const size = shape.halfExtents;
                const geometry = new THREE.BoxGeometry(size.x * 2, size.y * 2, size.z * 2);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                debugMesh = new THREE.Mesh(geometry, material);
            } else if (shape instanceof CANNON.Sphere) {
                const geometry = new THREE.SphereGeometry(shape.radius, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                debugMesh = new THREE.Mesh(geometry, material);
            } else if (shape instanceof CANNON.Heightfield) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                let { elementSize } = shape;
                const data = shape.data;

                elementSize = elementSize * 1.05;
                const maxX = (data.length - 1) * elementSize;
                const floorSize = (data.length - 1) * elementSize;
                const correctedElementSize = floorSize / (data.length - 1);

                for (let x = 0; x < data.length - 1; x++) {
                    for (let z = 0; z < data[0].length - 1; z++) {
                        const y00 = data[x][z];
                        const y10 = data[x + 1][z];
                        const y01 = data[x][z + 1];
                        const y11 = data[x + 1][z + 1];

                        const xPos = x * correctedElementSize;
                        const zPos = z * correctedElementSize;

                        vertices.push(maxX - xPos, y00, zPos);
                        vertices.push(maxX - (xPos + correctedElementSize), y10, zPos);
                        vertices.push(maxX - xPos, y01, zPos + correctedElementSize);
                        vertices.push(maxX - (xPos + correctedElementSize), y11, zPos + correctedElementSize);

                        const base = (x * (data[0].length - 1) + z) * 4;
                        indices.push(base, base + 1, base + 2);
                        indices.push(base + 1, base + 3, base + 2);
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                debugMesh = new THREE.Mesh(geometry, material);
            }
            return debugMesh;
        }

        function getShortestAngleDifference(currentAngle, targetAngle) {
            let delta = targetAngle - currentAngle;
            delta = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;
            return delta;
        }

        // 迷宮生成函數
        function generateMaze(gridSize, cellSize, removeWallPercentage = 0.8, obstacleProbability = 0.2, treasureProbability = 0.1) {
            const maze = new Array(gridSize);
            for (let i = 0; i < gridSize; i++) {
                maze[i] = new Array(gridSize).fill(0);
            }
            const obstacles = [];
            const treasures = [];

            function random(array) {
                if (Array.isArray(array)) return array[Math.floor(Math.random() * array.length)];
                return Math.random();
            }

            function getUnvisitedNeighbors(x, y) {
                const neighbors = [];
                const directions = [
                    { dx: 0, dy: -2 }, { dx: 0, dy: 2 },
                    { dx: -2, dy: 0 }, { dx: 2, dy: 0 }
                ];
                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    if (nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1 && maze[nx][ny] === 1) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                return neighbors;
            }

            function removeWall(x1, y1, x2, y2) {
                const wx = (x1 + x2) / 2;
                const wy = (y1 + y2) / 2;
                maze[wy][wx] = 0;
            }

            const stack = [];
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            stack.push({ x: startX, y: startY });

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(current.x, current.y);
                if (neighbors.length > 0) {
                    const next = random(neighbors);
                    removeWall(current.x, current.y, next.x, next.y);
                    maze[next.x][next.y] = 0;
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    if (maze[x][y] === 1 && random() < removeWallPercentage) {
                        maze[x][y] = 0;
                    }
                }
            }

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    if (maze[x][y] === 0 && !(x == 1 && y == 1)) {
                        if (random() < obstacleProbability) {
                            const durability = Math.floor(random() * 3) + 1;
                            obstacles.push({ x, z: y, durability });
                        } else if (random() < treasureProbability) {
                            const treasureTypes = ['health', 'attack', 'speed', 'bow'];
                            const type = treasureTypes[Math.floor(Math.random() * treasureTypes.length)];
                            treasures.push({ x, z: y, type });
                        }
                    }
                }
            }

            return { maze, obstacles, treasures };
        }

        // 地形生成函數
        function generateTerrain(gridSize, cellSize, obstacleProbability = 0.2, treasureProbability = 0.1) {
            const simplex = new SimplexNoise();
            const heightData = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
            const obstacles = [];
            const treasures = [];

            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    const noiseValue = simplex.noise2D(x / 20, z / 20);
                    heightData[x][z] = (noiseValue + 1) * 5;
                }
            }

            for (let x = 1; x < gridSize - 1; x++) {
                for (let z = 1; z < gridSize - 1; z++) {
                    if (Math.random() < obstacleProbability && !(x === 1 && z === 1)) {
                        obstacles.push({x, z, durability: Math.floor(Math.random() * 3) + 1});
                    } else if (Math.random() < treasureProbability && !(x === 1 && z === 1)) {
                        treasures.push({x, z, type: ['health', 'attack', 'speed', 'bow'][Math.floor(Math.random() * 4)]});
                    }
                }
            }

            return {heightData, obstacles, treasures};
        }

        function setupScene() {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 10, 40);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const world = new CANNON.World();
    world.gravity.set(0, -9.8, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.defaultContactMaterial.friction = 0.5;
    world.defaultContactMaterial.restitution = 0.1;

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.2);
    scene.add(hemiLight);

    const spotLight = new THREE.SpotLight(0xffffff, 1000);
    spotLight.position.set(0, 2, 0);
    spotLight.castShadow = true;
    spotLight.distance = 50;
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.2;
    spotLight.decay = 2;
    scene.add(spotLight);

    spotLight.target = new THREE.Object3D();
    scene.add(spotLight.target);

    return {
        scene, 
        camera, 
        renderer, 
        world, 
        spotLight, 
        controls: null, 
        clock: new THREE.Clock(),
        activeArrows: [],  // 預先初始化
        objectsToRemove: []  // 預先初始化
    };
}

        function createFloor(sceneInfo, gameInfo) {
            const floorSize = gameInfo.gridSize * gameInfo.cellSize;
            const geometry = new THREE.PlaneGeometry(floorSize, floorSize, gameInfo.gridSize - 1, gameInfo.gridSize - 1);
            const heightData = gameInfo.heightData || Array(gameInfo.gridSize).fill().map(() => Array(gameInfo.gridSize).fill(0));
            geometry.rotateX(-Math.PI / 2);
            const vertices = geometry.attributes.position.array;
            for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
                const x = Math.floor(j / gameInfo.gridSize);
                const z = j % gameInfo.gridSize;
                vertices[i + 1] = heightData[x][z]; 
            }
            geometry.computeVertexNormals();

            const floorTexture = textureLoader.load(ext_resource_url + '/textures/grass.png');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(gameInfo.gridSize / 2, gameInfo.gridSize / 2);
            const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });
            const floor = new THREE.Mesh(geometry, floorMaterial);
            floor.position.set(floorSize / 2, 0, floorSize / 2);
            floor.receiveShadow = true;
            sceneInfo.scene.add(floor);

            gameInfo.floorMesh = floor;

            const heightfieldShape = new CANNON.Heightfield(heightData, { elementSize: gameInfo.cellSize });
            var heightfieldBody = new CANNON.Body({ mass: 0 });
            
            var offsetX = -floorSize / 2;
            var offsetY = 0;
            var offsetZ = -floorSize / 2;
            var positionOffset = new CANNON.Vec3(offsetX, offsetY, offsetZ);

            var angleX = -Math.PI / 2;
            var angleY = Math.PI / 2 + Math.PI;
            var angleZ = 0;

            var q = new CANNON.Quaternion();
            var qx = new CANNON.Quaternion();
            qx.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), angleX);
            var qy = new CANNON.Quaternion();
            qy.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angleY);
            var qz = new CANNON.Quaternion();
            qz.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), angleZ);
            q = qz.mult(qy).mult(qx);

            heightfieldBody.addShape(heightfieldShape, positionOffset, q);
            heightfieldBody.position.set(floorSize / 2, 0, floorSize / 2);
            sceneInfo.world.addBody(heightfieldBody);
            gameInfo.floorBody = heightfieldBody;
            gameInfo.floorShapeOffset = positionOffset;
            gameInfo.floorShapeQuaternion = q;

            if (debugPhysics) {
                const debugMesh = createDebugMeshFromCannonShape(heightfieldBody, heightfieldShape);
                sceneInfo.scene.add(debugMesh);
                gameInfo.floorDebugMesh = debugMesh;
            }

            // 添加迷宮牆壁
            if (gameInfo.maze) {
                const wallTexture = textureLoader.load(ext_resource_url + '/textures/wall.png');
                wallTexture.wrapS = THREE.RepeatWrapping;
                wallTexture.wrapT = THREE.RepeatWrapping;
                wallTexture.repeat.set(1, 1);

                const wallGeometry = new THREE.BoxGeometry(gameInfo.cellSize, gameInfo.cellSize, gameInfo.cellSize);
                const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture });
                gameInfo.wallBoxes = [];

                for (let i = 0; i < gameInfo.maze.length; i++) {
                    for (let j = 0; j < gameInfo.maze[i].length; j++) {
                        if (gameInfo.maze[i][j] === 1) {
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            const posX = i * gameInfo.cellSize + gameInfo.cellSize / 2;
                            const posZ = j * gameInfo.cellSize + gameInfo.cellSize / 2;
                            const posY = getTerrainHeightAt(posX, posZ, gameInfo) + gameInfo.cellSize / 2;
                            wall.position.set(posX, posY, posZ);
                            wall.castShadow = true;
                            wall.receiveShadow = true;
                            sceneInfo.scene.add(wall);

                            const shape = new CANNON.Box(new CANNON.Vec3(gameInfo.cellSize / 2, gameInfo.cellSize / 2, gameInfo.cellSize / 2));
                            const body = new CANNON.Body({ mass: 0 });
                            body.addShape(shape);
                            body.position.set(posX, posY, posZ);
                            sceneInfo.world.addBody(body);

                            const box = new THREE.Box3().setFromObject(wall);
                            gameInfo.wallBoxes.push({ mesh: wall, body: body, box: box });
                        }
                    }
                }
            }
        }

        function getTerrainHeightAt(x, z, gameInfo) {
            const floor = gameInfo.floorMesh;
            if (!floor) return 0;

            const geometry = floor.geometry;
            const position = geometry.attributes.position;

            const localX = x - floor.position.x;
            const localZ = z - floor.position.z;

            const gridSize = gameInfo.gridSize - 1;
            const cellSize = gameInfo.cellSize;

            const gridX = Math.floor((localX + gameInfo.gridSize * gameInfo.cellSize / 2) / cellSize);
            const gridZ = Math.floor((localZ + gameInfo.gridSize * gameInfo.cellSize / 2) / cellSize);

            if (gridX < 0 || gridX >= gridSize || gridZ < 0 || gridZ >= gridSize) {
                return 0;
            }

            const index00 = gridZ * (gridSize + 1) + gridX;
            const index10 = gridZ * (gridSize + 1) + (gridX + 1);
            const index01 = (gridZ + 1) * (gridSize + 1) + gridX;
            const index11 = (gridZ + 1) * (gridSize + 1) + (gridX + 1);

            const h00 = position.array[index00 * 3 + 1];
            const h10 = position.array[index10 * 3 + 1];
            const h01 = position.array[index01 * 3 + 1];
            const h11 = position.array[index11 * 3 + 1];

            const tx = (localX - (gridX * cellSize - gameInfo.gridSize * gameInfo.cellSize / 2)) / cellSize;
            const tz = (localZ - (gridZ * cellSize - gameInfo.gridSize * gameInfo.cellSize / 2)) / cellSize;

            const height = h00 * (1 - tx) * (1 - tz) +
                         h10 * tx * (1 - tz) +
                         h01 * (1 - tx) * tz +
                         h11 * tx * tz;

            return height;
        }

        function createObstacles(sceneInfo, gameInfo) {
            const obstacleTexture = textureLoader.load(ext_resource_url + '/textures/obstacle.png');
            obstacleTexture.wrapS = obstacleTexture.wrapT = THREE.RepeatWrapping;
            obstacleTexture.repeat.set(1, 1);

            const obstacleGeometry = new THREE.BoxGeometry(gameInfo.cellSize / 2, gameInfo.cellSize / 2, gameInfo.cellSize / 2);
            const obstacleMeshes = [], obstacleBodies = [];
            const keyIndex = Math.floor(Math.random() * gameInfo.obstacles.length);
            let doorIndex = Math.floor(Math.random() * gameInfo.obstacles.length);
            while (doorIndex === keyIndex) doorIndex = Math.floor(Math.random() * gameInfo.obstacles.length);

            let keyPosition, doorPosition;

            gameInfo.obstacles.forEach((obstacle, index) => {
                const material = new THREE.MeshStandardMaterial({map: obstacleTexture});
                const mesh = new THREE.Mesh(obstacleGeometry, material);
                const posX = obstacle.x * gameInfo.cellSize + gameInfo.cellSize / 2;
                const posZ = obstacle.z * gameInfo.cellSize + gameInfo.cellSize / 2;
                const posY = getTerrainHeightAt(posX, posZ, gameInfo) + gameInfo.cellSize / 4;

                mesh.position.set(posX, posY, posZ);
                mesh.castShadow = mesh.receiveShadow = true;
                mesh.userData = {
                    durability: obstacle.durability,
                    health: obstacle.durability * 10,
                    hidesKey: index === keyIndex,
                    hidesDoor: index === doorIndex
                };
                sceneInfo.scene.add(mesh);

                const shape = new CANNON.Box(new CANNON.Vec3(gameInfo.cellSize / 4, gameInfo.cellSize / 4, gameInfo.cellSize / 4));
                const body = new CANNON.Body({mass: 0});
                body.addShape(shape);
                body.position.set(posX, posY, posZ);
                sceneInfo.world.addBody(body);
                obstacleMeshes.push(mesh);
                obstacleBodies.push(body);

                if (index === keyIndex) keyPosition = mesh.position.clone();
                if (index === doorIndex) doorPosition = mesh.position.clone();
            });

            const keyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 16);
            const keyMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            const key = new THREE.Mesh(keyGeometry, keyMaterial);
            key.position.copy(keyPosition);
            key.visible = false;
            sceneInfo.scene.add(key);

            const doorGeometry = new THREE.BoxGeometry(1, 2, 1);
            const doorMaterial = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide});
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.copy(doorPosition);
            door.visible = false;
            sceneInfo.scene.add(door);

            return {obstacleMeshes, obstacleBodies, key, door};
        }

        function createTreasures(sceneInfo, gameInfo) {
            const treasureTextures = {
                health: textureLoader.load(ext_resource_url + '/textures/treasure_health.png'),
                attack: textureLoader.load(ext_resource_url + '/textures/treasure_attack.png'),
                speed: textureLoader.load(ext_resource_url + '/textures/treasure_speed.png'),
                bow: textureLoader.load(ext_resource_url + '/textures/treasure_bow.png')
            };
            for (let type in treasureTextures) {
                treasureTextures[type].wrapS = treasureTextures[type].wrapT = THREE.RepeatWrapping;
                treasureTextures[type].repeat.set(1, 1);
            }

            const geometry = new THREE.SphereGeometry(gameInfo.cellSize / 4, 32, 32);
            gameInfo.treasureMeshes = new Map();
            gameInfo.treasures.forEach(treasure => {
                const material = new THREE.MeshStandardMaterial({map: treasureTextures[treasure.type]});
                const mesh = new THREE.Mesh(geometry, material);
                const posX = treasure.x * gameInfo.cellSize + gameInfo.cellSize / 2;
                const posZ = treasure.z * gameInfo.cellSize + gameInfo.cellSize / 2;
                const posY = getTerrainHeightAt(posX, posZ, gameInfo) + gameInfo.cellSize / 4;

                mesh.position.set(posX, posY, posZ);
                mesh.castShadow = mesh.receiveShadow = true;
                sceneInfo.scene.add(mesh);
                gameInfo.treasureMeshes.set(treasure, mesh);
            });
        }

        function createPlayer(sceneInfo) {
            let player = null;
            const gltfLoader = new GLTFLoader();
            gltfLoader.load(ext_resource_url + '/3d_module/RobotExpressive.glb', (gltf) => {
                const soldier = gltf.scene;
                soldier.scale.set(0.5, 0.5, 0.5);
                const startX = 1, startZ = 1;
                const posX = startX * gameMaster.gameInfo.cellSize + gameMaster.gameInfo.cellSize / 2;
                const posZ = startZ * gameMaster.gameInfo.cellSize + gameMaster.gameInfo.cellSize / 2;
                const posY = getTerrainHeightAt(posX, posZ, gameMaster.gameInfo);
                soldier.position.set(posX, posY, posZ);

                const originalMaterials = new Map();
                soldier.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = child.receiveShadow = true;
                        originalMaterials.set(child, child.material.clone());
                    }
                });
                sceneInfo.scene.add(soldier);

                const shape = new CANNON.Sphere(1);
                const body = new CANNON.Body({mass: 5});
                body.addShape(shape);
                body.position.set(posX, posY + 10, posZ);
                body.linearDamping = 0.1;
                body.angularDamping = 0.1;
                sceneInfo.world.addBody(body);
                
                const mixer = new THREE.AnimationMixer(soldier);
                const animations = gltf.animations;
                const actions = {
                    idle: mixer.clipAction(animations[0]),
                    run: mixer.clipAction(animations[3]),
                    attack: mixer.clipAction(animations[5])
                };
                actions.idle.play();

                const healthCanvas = document.createElement('canvas');
                healthCanvas.width = 128;
                healthCanvas.height = 16;
                const healthCtx = healthCanvas.getContext('2d');
                healthCtx.fillStyle = '#00ff00';
                healthCtx.fillRect(0, 0, 128, 16);

                const backgroundSprite = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(document.createElement('canvas'))}));
                backgroundSprite.scale.set(2, 0.25, 1);
                backgroundSprite.position.set(0, 5, 0);
                soldier.add(backgroundSprite);

                const healthSprite = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(healthCanvas)}));
                healthSprite.scale.set(2, 0.25, 1);
                healthSprite.position.set(0, 5, 0);
                soldier.add(healthSprite);

                player = {
                    soldier, body, mixer, actions, currentAction: actions.idle, targetAngle: 0, health: 100, maxHealth: 100,
                    isAttacking: false, attackCooldown: 0, baseAttackPower: 10, attackPowerBoost: 0, attackPowerBoostEndTime: 0,
                    maxAttackCooldown: 0.2, healthBar: healthSprite, healthBarBackground: backgroundSprite, healthCanvas, healthCtx,
                    lastHealTime: 0, healInterval: 1, isFlashing: false, flashDuration: 0.1, flashTimer: 0, originalMaterials,
                    hasKey: false, faceMouseTimer: 0, shiftToggle: false, baseSoldierSpeed: 10, speedMultiplier: 1,
                    speedPowerUpEndTime: 0, attackTriggeredByMouse: false, hasBow: true, arrowCount: 1
                };
                if (debugPhysics) {
                    const debugMesh = createDebugMeshFromCannonShape(body, shape);
                    sceneInfo.scene.add(debugMesh);
                    player.debugMesh = debugMesh;
                }
            });
            return () => player;
        }

        function updatePlayer(playerInfo, inputInfo, sceneInfo, gameInfo, enemyInfo, delta) {
            const player = playerInfo.getPlayer();
            if (!player || !player.soldier) return;

            const { soldier, mixer, actions, currentAction } = player;

            soldier.visible = gameMaster.cameraMode !== 'firstPerson';

            if (player.isFlashing) {
                player.flashTimer -= delta;
                const flashIntensity = Math.abs(Math.sin(player.flashTimer * Math.PI * 10));
                soldier.traverse(child => {
                    if (child.isMesh) child.material.color.setRGB(1, flashIntensity / 2, flashIntensity / 2);
                });
                if (player.flashTimer <= 0) {
                    player.isFlashing = false;
                    soldier.traverse(child => {
                        if (child.isMesh && player.originalMaterials.has(child)) {
                            child.material = player.originalMaterials.get(child).clone();
                        }
                    });
                }
            }

            const rotationSpeed = 5;
            const soldierSpeed = player.baseSoldierSpeed * player.speedMultiplier;
            const moveDirection = new THREE.Vector3();
            let isRotating = false;

            const currentTime = Date.now();
            if (player.attackPowerBoostEndTime > 0 && currentTime > player.attackPowerBoostEndTime) {
                player.attackPowerBoost = 0;
                player.attackPowerBoostEndTime = 0;
            }
            if (player.speedPowerUpEndTime > 0 && currentTime > player.speedPowerUpEndTime) {
                player.speedMultiplier = 1;
                player.speedPowerUpEndTime = 0;
            }

            // 移動邏輯（保持不變）
            if (gameMaster.cameraMode === 'firstPerson') {
                if (inputInfo.keys.joystick.y !== 0) {
                    const forwardDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(soldier.quaternion).normalize();
                    moveDirection.add(forwardDirection.multiplyScalar(-inputInfo.keys.joystick.y));
                }
                if (inputInfo.keys.joystick.x !== 0) {
                    soldier.rotation.y -= inputInfo.keys.joystick.x * rotationSpeed * delta;
                    isRotating = true;
                }

                const forward = new THREE.Vector3();
                const left = new THREE.Vector3();
                sceneInfo.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                left.copy(forward).applyAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2).normalize();

                if (inputInfo.keys.w) moveDirection.add(forward);
                if (inputInfo.keys.s) moveDirection.sub(forward);
                if (inputInfo.keys.shift || inputInfo.keys.mouseLeft) {
                    if (inputInfo.keys.a) moveDirection.sub(left);
                    if (inputInfo.keys.d) moveDirection.add(left);
                } else {
                    if (inputInfo.keys.a) {
                        soldier.rotation.y += rotationSpeed * delta;
                        isRotating = true;
                    }
                    if (inputInfo.keys.d) {
                        soldier.rotation.y -= rotationSpeed * delta;
                        isRotating = true;
                    }
                }
                if (inputInfo.keys.mouseLeft) {
                    let mv = Math.min(Math.max(inputInfo.keys.mouseMovementX, -32), 32);
                    soldier.rotation.y -= mv * 0.01;
                }
            } else {
                const forward = new THREE.Vector3();
                const left = new THREE.Vector3();
                sceneInfo.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                left.copy(forward).applyAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2).normalize();

                if (inputInfo.keys.w) moveDirection.add(forward);
                if (inputInfo.keys.s) moveDirection.sub(forward);
                if (inputInfo.keys.a) moveDirection.sub(left);
                if (inputInfo.keys.d) moveDirection.add(left);
                if (inputInfo.keys.joystick.x !== 0 || inputInfo.keys.joystick.y !== 0) {
                    moveDirection.add(left.multiplyScalar(inputInfo.keys.joystick.x)).add(forward.multiplyScalar(-inputInfo.keys.joystick.y));
                }
                moveDirection.normalize();
            }

            const isMoving = moveDirection.lengthSq() > 0 || isRotating;
            if (player.attackCooldown > 0) player.attackCooldown -= delta;

            // Shift + 滑鼠控制朝向（非第一人稱）
            if (player.shiftToggle && gameMaster.cameraMode !== 'firstPerson') {
                player.faceMouseTimer -= delta;
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(inputInfo.mouse, sceneInfo.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -soldier.position.y);
                const intersect = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersect);
                const direction = intersect.sub(soldier.position).normalize();
                direction.y = 0;
                const targetAngle = Math.atan2(direction.x, direction.z);
                soldier.rotation.y += getShortestAngleDifference(soldier.rotation.y, targetAngle) * rotationSpeed * delta;
            }

            // 攻擊邏輯
            if ((inputInfo.keys.space || player.attackTriggeredByMouse) && player.attackCooldown <= 0) {
                player.isAttacking = true;
                if (currentAction !== actions.attack) {
                    if (currentAction) currentAction.fadeOut(0.2);
                    actions.attack.reset().fadeIn(0.2).play();
                    player.currentAction = actions.attack;
                }
                player.attackCooldown = player.maxAttackCooldown;
                player.attackTriggeredByMouse = false;

                const playerForward = new THREE.Vector3(0, 0, 1).applyQuaternion(soldier.quaternion).normalize();

                if (player.hasBow && player.arrowCount > 0) {
                    player.arrowCount--;
                    const arrowGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                    const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                    arrow.position.copy(soldier.position).add(playerForward.clone().multiplyScalar(1)).add(new THREE.Vector3(0, 1, 0));
                    const direction = new THREE.Vector3(playerForward.x, 0, playerForward.z).normalize();
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                    arrow.quaternion.multiply(quaternion);
                    sceneInfo.scene.add(arrow);

                    const arrowBody = new CANNON.Body({ mass: 0.1 });
                    arrowBody.addShape(new CANNON.Box(new CANNON.Vec3(0.025, 0.5, 0.025)));
                    arrowBody.position.copy(arrow.position);
                    arrowBody.quaternion.copy(arrow.quaternion);
                    const arrowSpeed = 30;
                    arrowBody.velocity.set(playerForward.x * arrowSpeed, 0, playerForward.z * arrowSpeed);
                    arrowBody.hasHit = false;
                    sceneInfo.world.addBody(arrowBody);

                    if (!sceneInfo.activeArrows) sceneInfo.activeArrows = [];
                    sceneInfo.activeArrows.push({ mesh: arrow, body: arrowBody });

                    arrowBody.addEventListener('collide', (e) => {
                        if (arrowBody.hasHit) return;
                        const target = e.body;

                        enemyInfo.enemies.forEach((enemy, idx) => {
                            if (enemy.body === target) {
                                enemy.health -= player.baseAttackPower + player.attackPowerBoost;
                                arrowBody.hasHit = true;
                                sceneInfo.objectsToRemove.push({ mesh: arrow, body: arrowBody });
                                if (enemy.health <= 0) {
                                    sceneInfo.objectsToRemove.push({ mesh: enemy.mesh, body: enemy.body, enemyIdx: idx });
                                }
                            }
                        });

                        const obstacleIdx = gameInfo.obstacleBodies.indexOf(target);
                        if (obstacleIdx !== -1) {
                            const obstacle = gameInfo.obstacleMeshes[obstacleIdx];
                            obstacle.userData.health -= player.baseAttackPower + player.attackPowerBoost;
                            arrowBody.hasHit = true;
                            sceneInfo.objectsToRemove.push({ mesh: arrow, body: arrowBody });
                            if (obstacle.userData.health <= 0) {
                                if (obstacle.userData.hidesKey) gameInfo.key.visible = true;
                                if (obstacle.userData.hidesDoor) gameInfo.door.visible = true;
                                sceneInfo.objectsToRemove.push({ mesh: obstacle, body: target, obstacleIdx });
                            }
                        }

                        if (gameInfo.wallBoxes) {
                            const wallIdx = gameInfo.wallBoxes.findIndex(w => w.body === target);
                            if (wallIdx !== -1) {
                                arrowBody.hasHit = true;
                                sceneInfo.objectsToRemove.push({ mesh: arrow, body: arrowBody });
                            }
                        }
                    });
                } else {
                    enemyInfo.enemies.forEach((enemy, idx) => {
                        const distance = soldier.position.distanceTo(enemy.mesh.position);
                        if (distance < 3) {
                            const enemyDirection = enemy.mesh.position.clone().sub(soldier.position).normalize();
                            const angleDeg = Math.acos(playerForward.dot(enemyDirection)) * 180 / Math.PI;
                            if (angleDeg <= 60) {
                                enemy.health -= player.baseAttackPower + player.attackPowerBoost;
                                if (enemy.health <= 0) {
                                    sceneInfo.objectsToRemove.push({ mesh: enemy.mesh, body: enemy.body, enemyIdx: idx });
                                }
                            }
                        }
                    });

                    gameInfo.obstacleMeshes.forEach((obstacle, idx) => {
                        const distance = soldier.position.distanceTo(obstacle.position);
                        if (distance < 3) {
                            const obstacleDirection = obstacle.position.clone().sub(soldier.position).normalize();
                            const angleDeg = Math.acos(playerForward.dot(obstacleDirection)) * 180 / Math.PI;
                            if (angleDeg <= 60) {
                                obstacle.userData.health -= player.baseAttackPower + player.attackPowerBoost;
                                if (obstacle.userData.health <= 0) {
                                    if (obstacle.userData.hidesKey) gameInfo.key.visible = true;
                                    if (obstacle.userData.hidesDoor) gameInfo.door.visible = true;
                                    sceneInfo.objectsToRemove.push({ mesh: obstacle, body: gameInfo.obstacleBodies[idx], obstacleIdx: idx });
                                }
                            }
                        }
                    });
                }

                setTimeout(() => {
                    player.isAttacking = false;
                    if (!isMoving && currentAction !== actions.idle) {
                        if (currentAction) currentAction.fadeOut(0.2);
                        actions.idle.reset().fadeIn(0.2).play();
                        player.currentAction = actions.idle;
                    }
                }, player.maxAttackCooldown * 500);
            } else if (isMoving && !player.isAttacking) {
                if (gameMaster.cameraMode !== 'firstPerson') {
                    const angle = Math.atan2(moveDirection.x, moveDirection.z);
                    soldier.rotation.y += getShortestAngleDifference(soldier.rotation.y, angle) * rotationSpeed * delta;
                }
                player.body.velocity.set(moveDirection.x * soldierSpeed, player.body.velocity.y, moveDirection.z * soldierSpeed);
                if (currentAction !== actions.run) {
                    if (currentAction) currentAction.fadeOut(0.2);
                    actions.run.reset().fadeIn(0.2).play();
                    player.currentAction = actions.run;
                }
            } else if (!player.isAttacking) {
                if (currentAction !== actions.idle) {
                    if (currentAction) currentAction.fadeOut(0.2);
                    actions.idle.reset().fadeIn(0.2).play();
                    player.currentAction = actions.idle;
                }
                player.body.velocity.set(0, player.body.velocity.y, 0);
            }

            // 更新箭矢
            if (!sceneInfo.activeArrows) sceneInfo.activeArrows = [];
            for (let i = sceneInfo.activeArrows.length - 1; i >= 0; i--) {
                const arrow = sceneInfo.activeArrows[i];
                if (arrow && arrow.mesh && arrow.body) {
                    arrow.mesh.position.copy(arrow.body.position);
                    arrow.mesh.quaternion.copy(arrow.body.quaternion);
                    if (arrow.body.velocity.length() < 0.1 && !arrow.body.hasHit) {
                        sceneInfo.objectsToRemove.push({ mesh: arrow.mesh, body: arrow.body });
                        sceneInfo.activeArrows.splice(i, 1);
                    }
                }
            }

            // 清理移除的對象
            if (!sceneInfo.objectsToRemove) sceneInfo.objectsToRemove = [];
            sceneInfo.objectsToRemove.forEach(obj => {
                sceneInfo.scene.remove(obj.mesh);
                sceneInfo.world.remove(obj.body);
                if (obj.enemyIdx !== undefined) enemyInfo.enemies.splice(obj.enemyIdx, 1);
                if (obj.obstacleIdx !== undefined) {
                    gameInfo.obstacleMeshes.splice(obj.obstacleIdx, 1);
                    gameInfo.obstacleBodies.splice(obj.obstacleIdx, 1);
                }
                const arrowIdx = sceneInfo.activeArrows.findIndex(a => a.body === obj.body);
                if (arrowIdx !== -1) sceneInfo.activeArrows.splice(arrowIdx, 1);
            });
            sceneInfo.objectsToRemove = [];

            // 寶藏收集
            const treasuresToRemove = [];
            gameInfo.treasureMeshes.forEach((mesh, treasure) => {
                if (!mesh || !mesh.position) {
                    treasuresToRemove.push(treasure);
                    return;
                }
                if (soldier.position.distanceTo(mesh.position) < 1.25) {
                    switch (treasure.type) {
                        case 'health': player.health = Math.min(player.health + 10, player.maxHealth); break;
                        case 'attack': player.attackPowerBoost = 5; player.attackPowerBoostEndTime = currentTime + 10000; break;
                        case 'speed': player.speedMultiplier = 1.5; player.speedPowerUpEndTime = currentTime + 10000; break;
                        case 'bow': player.hasBow = true; player.arrowCount += 50; break;
                    }
                    sceneInfo.scene.remove(mesh);
                    treasuresToRemove.push(treasure);
                }
            });
            treasuresToRemove.forEach(treasure => gameInfo.treasureMeshes.delete(treasure));

            // 鑰匙和門
            if (gameInfo.key.visible && soldier.position.distanceTo(gameInfo.key.position) < 2) {
                player.hasKey = true;
                gameInfo.key.visible = false;
            }
            if (gameInfo.door.visible && player.hasKey && soldier.position.distanceTo(gameInfo.door.position) < 2) {
                gameMaster.newGame = true;
            }

            mixer.update(delta);
            sceneInfo.world.step(delta);
            soldier.position.copy(player.body.position);
            soldier.position.y -= 1;

            // 聚光燈
            const spotlightDirection = new THREE.Vector3(0, 25, -15).applyQuaternion(soldier.quaternion).normalize();
            sceneInfo.spotLight.position.copy(soldier.position).add(spotlightDirection.multiplyScalar(10)).add(new THREE.Vector3(0, 15, 0));
            sceneInfo.spotLight.target.position.copy(soldier.position).add(new THREE.Vector3(0, 0, 5).applyQuaternion(soldier.quaternion));
            sceneInfo.scene.add(sceneInfo.spotLight.target);

            // 生命恢復
            const elapsedTime = sceneInfo.clock.getElapsedTime();
            if (elapsedTime - player.lastHealTime >= player.healInterval && player.health < player.maxHealth) {
                player.health += 1;
                player.lastHealTime = elapsedTime;
            }

            // 生命條更新
            const healthPercentage = player.health / player.maxHealth;
            player.healthCtx.clearRect(0, 0, 128, 16);
            player.healthCtx.fillStyle = healthPercentage > 0.3 ? '#00ff00' : '#ff0000';
            player.healthCtx.fillRect(0, 0, 128 * healthPercentage, 16);
            player.healthBar.material.map.needsUpdate = true;

            // 相機控制（修復部分）
            if (gameMaster.cameraMode === 'firstPerson') {
                sceneInfo.camera.position.copy(soldier.position).add(new THREE.Vector3(0, 2, 0));
                // 重置相機旋轉並設置正確的 Y 軸朝向
                sceneInfo.camera.rotation.set(0, soldier.rotation.y + Math.PI - Math.PI / 2, 0);
            } else if (gameMaster.cameraMode === 'topDown') {
                sceneInfo.camera.position.set(soldier.position.x, 20, soldier.position.z);
                sceneInfo.camera.lookAt(soldier.position);
            } else if (sceneInfo.controls) {
                sceneInfo.controls.target.copy(soldier.position);
                sceneInfo.controls.update();
            }

            document.getElementById('debug').innerText = `Player HP: ${player.health}\nArrows: ${player.arrowCount}\nAttack Power: ${player.baseAttackPower + player.attackPowerBoost}\nSpeed: ${player.baseSoldierSpeed * player.speedMultiplier}`;
        }

        function spawnEnemy(sceneInfo, gameInfo, enemyInfo, maxEnemies) {
            if (enemyInfo.enemies.length >= maxEnemies) return;

            const gltfLoader = new GLTFLoader();
            gltfLoader.load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
                const enemy = gltf.scene;
                enemy.scale.set(0.5, 0.5, 0.5);
                let spawnX, spawnZ;
                do {
                    spawnX = Math.floor(Math.random() * gameInfo.gridSize);
                    spawnZ = Math.floor(Math.random() * gameInfo.gridSize);
                } while (spawnX === 1 && spawnZ === 1 || 
                        gameInfo.obstacles.some(o => o.x === spawnX && o.z === spawnZ) ||
                        (gameInfo.maze && gameInfo.maze[spawnX][spawnZ] === 1));

                const posX = spawnX * gameInfo.cellSize + gameInfo.cellSize / 2;
                const posZ = spawnZ * gameInfo.cellSize + gameInfo.cellSize / 2;
                const posY = getTerrainHeightAt(posX, posZ, gameInfo);
                enemy.position.set(posX, posY, posZ);
                enemy.traverse(child => child.isMesh && (child.castShadow = child.receiveShadow = true, child.material.color.setRGB(1, 0, 0)));
                sceneInfo.scene.add(enemy);

                const shape = new CANNON.Sphere(1);
                const body = new CANNON.Body({mass: 5});
                body.addShape(shape);
                body.position.set(posX, posY + 1, posZ);
                body.linearDamping = 0.1;
                sceneInfo.world.addBody(body);

                enemyInfo.enemies.push({mesh: enemy, body, health: 50, speed: 5});
            });
        }

        function updateEnemies(sceneInfo, gameInfo, enemyInfo, playerInfo, delta) {
            const player = playerInfo.getPlayer();
            if (!player) return;

            enemyInfo.enemies.forEach(enemy => {
                enemy.mesh.position.copy(enemy.body.position);
                enemy.mesh.position.y -= 1;

                const direction = player.soldier.position.clone().sub(enemy.mesh.position).normalize();
                direction.y = 0;
                const targetAngle = Math.atan2(direction.x, direction.z);
                enemy.mesh.rotation.y += getShortestAngleDifference(enemy.mesh.rotation.y, targetAngle) * 5 * delta;

                const distance = enemy.mesh.position.distanceTo(player.soldier.position);
                if (distance > 2) {
                    enemy.body.velocity.set(direction.x * enemy.speed, enemy.body.velocity.y, direction.z * enemy.speed);
                } else {
                    enemy.body.velocity.set(0, enemy.body.velocity.y, 0);
                    if (Math.random() < 0.01) {
                        player.health -= 5;
                        player.isFlashing = true;
                        player.flashTimer = player.flashDuration;
                    }
                }
            });
        }

        const gameMaster = {
            sceneInfo: setupScene(),
            gameInfo: {},
            playerInfo: null,
            enemyInfo: {enemies: []},
            inputInfo: {
                keys: {w: false, a: false, s: false, d: false, space: false, shift: false, mouseLeft: false, mouseMovementX: 0, joystick: {x: 0, y: 0}},
                mouse: new THREE.Vector2()
            },
            cameraMode: 'perspective',
            newGame: false
        };

        function initGame() {
            const gridSize = 21; // 必須是奇數以適應迷宮生成
            const cellSize = 2;

            // 生成地形和迷宮
            const terrainData = generateTerrain(gridSize, cellSize);
            const mazeData = generateMaze(gridSize, cellSize);
            gameMaster.gameInfo = {
                gridSize,
                cellSize,
                heightData: terrainData.heightData,
                maze: mazeData.maze,
                obstacles: terrainData.obstacles,
                treasures: terrainData.treasures,
                treasureMeshes: new Map()
            };

            createFloor(gameMaster.sceneInfo, gameMaster.gameInfo);
            const obstacles = createObstacles(gameMaster.sceneInfo, gameMaster.gameInfo);
            gameMaster.gameInfo.obstacleMeshes = obstacles.obstacleMeshes;
            gameMaster.gameInfo.obstacleBodies = obstacles.obstacleBodies;
            gameMaster.gameInfo.key = obstacles.key;
            gameMaster.gameInfo.door = obstacles.door;
            createTreasures(gameMaster.sceneInfo, gameMaster.gameInfo);

            gameMaster.playerInfo = { getPlayer: createPlayer(gameMaster.sceneInfo) };
            gameMaster.sceneInfo.controls = new OrbitControls(gameMaster.sceneInfo.camera, gameMaster.sceneInfo.renderer.domElement);
            gameMaster.sceneInfo.controls.enableDamping = true;
            gameMaster.sceneInfo.controls.dampingFactor = 0.05;

            document.addEventListener('keydown', (e) => {
                if (e.key === 'w') gameMaster.inputInfo.keys.w = true;
                if (e.key === 'a') gameMaster.inputInfo.keys.a = true;
                if (e.key === 's') gameMaster.inputInfo.keys.s = true;
                if (e.key === 'd') gameMaster.inputInfo.keys.d = true;
                if (e.key === ' ') gameMaster.inputInfo.keys.space = true;
                if (e.key === 'Shift') gameMaster.inputInfo.keys.shift = true;
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'w') gameMaster.inputInfo.keys.w = false;
                if (e.key === 'a') gameMaster.inputInfo.keys.a = false;
                if (e.key === 's') gameMaster.inputInfo.keys.s = false;
                if (e.key === 'd') gameMaster.inputInfo.keys.d = false;
                if (e.key === ' ') gameMaster.inputInfo.keys.space = false;
                if (e.key === 'Shift') {
                    gameMaster.inputInfo.keys.shift = false;
                    const player = gameMaster.playerInfo.getPlayer();
                    if (player) player.shiftToggle = !player.shiftToggle;
                }
            });

            document.addEventListener('mousemove', (e) => {
                gameMaster.inputInfo.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                gameMaster.inputInfo.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                gameMaster.inputInfo.keys.mouseMovementX = e.movementX;
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    gameMaster.inputInfo.keys.mouseLeft = true;
                    const player = gameMaster.playerInfo.getPlayer();
                    if (player) player.attackTriggeredByMouse = true;
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) gameMaster.inputInfo.keys.mouseLeft = false;
            });

            const joystickContainer = document.getElementById('joystick-container');
            const joystick = document.getElementById('joystick');
            let isDragging = false;

            joystickContainer.addEventListener('touchstart', (e) => {
                isDragging = true;
                handleJoystickMove(e.touches[0]);
            });

            joystickContainer.addEventListener('touchmove', (e) => {
                if (isDragging) handleJoystickMove(e.touches[0]);
            });

            joystickContainer.addEventListener('touchend', () => {
                isDragging = false;
                gameMaster.inputInfo.keys.joystick.x = 0;
                gameMaster.inputInfo.keys.joystick.y = 0;
                joystick.style.left = '50%';
                joystick.style.top = '50%';
            });

            function handleJoystickMove(event) {
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dx = event.clientX - centerX;
                const dy = event.clientY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = rect.width / 2 - joystick.offsetWidth / 2;

                let angle = Math.atan2(dy, dx);
                let magnitude = Math.min(distance, maxDistance);
                let x = Math.cos(angle) * magnitude;
                let y = Math.sin(angle) * magnitude;

                joystick.style.left = `${centerX - rect.left + x}px`;
                joystick.style.top = `${centerY - rect.top + y}px`;

                gameMaster.inputInfo.keys.joystick.x = x / maxDistance;
                gameMaster.inputInfo.keys.joystick.y = y / maxDistance;
            }

            document.getElementById('attack-button').addEventListener('click', () => {
                const player = gameMaster.playerInfo.getPlayer();
                if (player) player.attackTriggeredByMouse = true;
            });

            document.querySelectorAll('#camera-buttons button').forEach(button => {
                button.addEventListener('click', () => {
                    gameMaster.cameraMode = button.dataset.camera;
                    if (gameMaster.cameraMode === 'perspective' && !gameMaster.sceneInfo.controls) {
                        gameMaster.sceneInfo.controls = new OrbitControls(gameMaster.sceneInfo.camera, gameMaster.sceneInfo.renderer.domElement);
                    } else if (gameMaster.cameraMode !== 'perspective' && gameMaster.sceneInfo.controls) {
                        gameMaster.sceneInfo.controls.dispose();
                        gameMaster.sceneInfo.controls = null;
                    }
                });
            });

            function animate() {
                requestAnimationFrame(animate);
                const delta = gameMaster.sceneInfo.clock.getDelta();

                if (gameMaster.newGame) {
                    gameMaster.sceneInfo.scene.clear();
                    gameMaster.sceneInfo.world.bodies.forEach(body => gameMaster.sceneInfo.world.remove(body));
                    gameMaster.sceneInfo = setupScene();  // 使用更新後的 setupScene
                    gameMaster.enemyInfo.enemies = [];
                    initGame();
                    gameMaster.newGame = false;
                    return;
                }

                const player = gameMaster.playerInfo.getPlayer();
                if (player && player.soldier) {
                    updatePlayer(gameMaster.playerInfo, gameMaster.inputInfo, gameMaster.sceneInfo, gameMaster.gameInfo, gameMaster.enemyInfo, delta);
                    spawnEnemy(gameMaster.sceneInfo, gameMaster.gameInfo, gameMaster.enemyInfo, 5);
                    updateEnemies(gameMaster.sceneInfo, gameMaster.gameInfo, gameMaster.enemyInfo, gameMaster.playerInfo, delta);
                }

                gameMaster.sceneInfo.renderer.render(gameMaster.sceneInfo.scene, gameMaster.sceneInfo.camera);
            }
            animate();
        }

        initGame();
    </script>
</body>
</html>