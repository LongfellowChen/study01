<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #container_1 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #camera-buttons {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
        }
        #camera-buttons button {
            padding: 8px 12px;
            margin: 0 5px;
            font-size: 14px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #camera-buttons button:hover {
            background-color: #367C39;
        }
        #joystick-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            z-index: 100;
            touch-action: none;
        }
        #joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="camera-buttons">
        <button data-camera="perspective">(1)</button>
        <button data-camera="firstPerson">(2)</button>
        <button data-camera="topDown">(3)</button>
    </div>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>
    <div id="container_1"></div>

    <script type="importmap">{ "imports" : {
        "three" : "https://cdn.jsdelivr.net/gh/LongfellowChen/study01@master/node_modules/three/build/three.module.js",
        "three/webgpu" : "https://cdn.jsdelivr.net/gh/LongfellowChen/study01@master/node_modules/three/build/three.webgpu.min.js",
        "three/tsl" : "https://cdn.jsdelivr.net/gh/LongfellowChen/study01@master/node_modules/three/build/three.tsl.min.js",
        "three/addons/" : "https://cdn.jsdelivr.net/gh/LongfellowChen/study01@master/node_modules/three/examples/jsm/"
    }}</script>

    <script type="module">
        import * as THREE from "three/webgpu";
        import {
            Fn, If, uniform, time, texture, uv, instanceIndex,
            pass, screenUV, screenCoordinate,
            float, vec2, vec3, vec4,
            fract, floor, abs, negate, clamp, max, mix, dot, step, smoothstep,
            length, sin, cos,
            positionWorld, positionLocal, positionGeometry, cameraPosition
        } from "three/tsl";
        import Stats from "three/addons/libs/stats.module.js";
        import { GUI } from "three/addons/libs/lil-gui.module.min.js";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
        import { bayer16 } from "three/addons/tsl/math/Bayer.js";
        import { gaussianBlur } from "three/addons/tsl/display/GaussianBlurNode.js";
        import * as CANNON from 'https://cdn.skypack.dev/cannon-es';

        const ext_resource_url = 'https://cdn.jsdelivr.net/gh/LongfellowChen/study01@master';

        // Constants
        const LAYER_VOLUMETRIC_LIGHTING = 10;
        const MAX_BRICK_COUNT = 100;
        const PENZ_POSITION = -5;
        const BEAM_SPAN_LENGTH = 2;
        const INITIAL_TONE_MAPPING_EXPOSURE = 2;
        const GROUND_SIZE = 100;
        const MOVE_SPEED = 15;
        const ROTATION_SPEED = 10;

        // Renderer Setup
// 初始化渲染器
const container = document.getElementById("container_1");
const renderer = new THREE.WebGPURenderer();
renderer.setPixelRatio(window.devicePixelRatio); // 使用設備像素比率以提高清晰度
renderer.setAnimationLoop(tick);
renderer.setSize(window.innerWidth, window.innerHeight); // 設置為視窗大小
renderer.toneMappingExposure = INITIAL_TONE_MAPPING_EXPOSURE;
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(-8, 5, 9);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const stats = new Stats();
        container.appendChild(stats.dom);

        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0, 2, -4);
        orbitControls.maxDistance = 40;
        orbitControls.minDistance = 2;

        let cameraMode = 'perspective';
        const inputKeys = {
            w: false, a: false, s: false, d: false,
            shift: false, space: false,
            '1': false, '2': false, '3': false,
            mouseLeft: false, mouseMovementX: 0, mouseMovementY: 0,
            joystick: { x: 0, y: 0 }
        };
        const mouse = new THREE.Vector2();

        // Penguin Variables
        let penguin, leftArm, rightArm, neckRoot, neckMid, neckEnd, beak;

        // Load Penguin
        const gltfLoader = new GLTFLoader();
        gltfLoader.load(ext_resource_url + "/3d_module/penguin.glb?1", function (gltf) {
            penguin = gltf.scene;
            penguin.traverse(function (object) {
                if (0 <= object.name.indexOf("arm_l")) leftArm = object;
                else if (0 <= object.name.indexOf("arm_r")) rightArm = object;
                else if (0 <= object.name.indexOf("neck_0")) neckRoot = object;
                else if (0 <= object.name.indexOf("neck_1")) neckMid = object;
                else if (0 <= object.name.indexOf("neck_2")) neckEnd = object;
                else if (0 <= object.name.indexOf("beak")) beak = object;
                if (object.geometry) object.castShadow = object.receiveShadow = true;
                if (object.material) object.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
            });
            penguin.position.set(0, 0, PENZ_POSITION);
            penguin.scale.setScalar(0.5);
            scene.add(penguin);
        });

        // Utility Functions
        function mm_hash12(iw) {
            const w = iw.mul(0.000303).add(fract(iw.mul(0.707)));
            const a = w.x.add(w.y.mul(0.3));
            a.assign(fract(a));
            a.assign(a.sub(a.mul(a)));
            return fract(a.mul(937652.481));
        }

        function rnd_dir(ip) {
            return fract(vec3(1, 99, 9999).mul(mm_hash12(ip.xy.add(ip.zz.mul(100))))).sub(0.5);
        }

        function simplex3d(p) {
            const ip = floor(p.add(dot(vec3(0.333333), p)));
            const p0 = p.sub(ip).add(dot(vec3(0.166666), ip));
            const f = step(p0.yzx, p0);
            const ff = f.mul(f.zxy);
            const v1 = f.sub(ff);
            const v2 = ff.sub(f.zxy).add(1);
            const p1 = p0.sub(v1).add(0.166666);
            const p2 = p0.sub(v2).add(0.333333);
            const p3 = p0.sub(1).add(0.5);
            const d = max(negate(vec4(
                dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)
            )).add(0.58), 0);
            d.assign(d.mul(d));
            d.assign(d.mul(d));
            return dot(vec4(
                dot(p0, rnd_dir(ip)), dot(p1, rnd_dir(ip.add(v1))),
                dot(p2, rnd_dir(ip.add(v2))), dot(p3, rnd_dir(ip.add(1)))
            ), d).mul(40).add(0.5);
        }

        function smoke(p) {
            const a = simplex3d(p.add(vec3(1, -0.7, 0).mul(time).mul(2)).mul(0.07));
            const b = simplex3d(p.add(vec3(1, -0.7, 0).mul(time).mul(3)).mul(0.3));
            const c = simplex3d(p.add(vec3(1, -0.7, 0).mul(time).mul(4)).mul(0.9));
            return vec3(1, 1, 1).mul(
                a.mul(a.add(0.2)).mul(1)
                    .add(b.mul(b).mul(0.5))
                    .add(c.mul(c).mul(0.5))
            ).min(1);
        }

        const smokeAmount = uniform(2);
        const volumeNodeMaterial = new THREE.VolumeNodeMaterial();
        volumeNodeMaterial.steps = 2;
        volumeNodeMaterial.offsetNode = bayer16(screenCoordinate);
        volumeNodeMaterial.scatteringNode = Fn(({ positionRay }) => {
            return mix(vec3(1), smoke(positionRay).add(0.5), smokeAmount);
        });

        const smokeBox = new THREE.Mesh(new THREE.BoxGeometry(GROUND_SIZE, 10, GROUND_SIZE), volumeNodeMaterial);
        smokeBox.receiveShadow = true;
        smokeBox.position.y = 5;
        smokeBox.layers.disableAll();
        smokeBox.layers.enable(LAYER_VOLUMETRIC_LIGHTING);
        scene.add(smokeBox);

        const shotHalf = uniform(0);
        function beam(color, phase) {
            const a = float().toVar();
            const b = float().toVar();
            const h = float().toVar();

            a.assign(smoke(positionWorld).add(0.5));
            b.assign(positionGeometry.z);
            h.assign(time.mul(7));
            h.addAssign(phase);
            h.addAssign(b.div(BEAM_SPAN_LENGTH).sub(h).floor().add(0.5));
            b.assign(b.clamp(
                h.sub(shotHalf).mul(BEAM_SPAN_LENGTH),
                h.add(shotHalf).mul(BEAM_SPAN_LENGTH)
            ));
            b.assign(length(positionGeometry.xz.sub(vec2(0, b))));
            h.assign(float(0.05).div(b).sub(0.05 / 1.5));
            h.addAssign(smoothstep(-1.5, 1.5, b.negate())
                .mul(smoothstep(-1.5, 1.5, b.negate()))
                .mul(0.2)
            );
            h.mulAssign(mix(1, a.mul(a), smokeAmount));
            return vec4(
                color.add(h.sub(1).max(1).sub(1)).clamp(0, 0.7),
                h.clamp(0, 0.7)
                    .mul(smoothstep(0, 1, positionWorld.y))
                    .mul(smoothstep(0, 0.5, positionGeometry.z))
            );
        }

        const beamRed = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 20).rotateX(-1.57080).translate(0, 0, 10),
            new THREE.MeshBasicNodeMaterial({ transparent: true, blending: THREE.AdditiveBlending, depthWrite: false })
        );
        beamRed.material.fragmentNode = Fn(() => beam(vec3(1, 0.05, 0.3), 0))();
        scene.add(beamRed);

        const beamBlue = beamRed.clone();
        beamBlue.material = beamRed.material.clone();
        beamBlue.material.fragmentNode = Fn(() => beam(vec3(1, 0.3, 0.05), 0.5))();
        scene.add(beamBlue);

        const orthographicCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
        const orthographicPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2));
        const orthographicScene = new THREE.Scene();
        orthographicScene.add(orthographicPlane);

        const brickRenderTargets = new Array(2);
        let brickRenderTargetIndex = 0;
        const brickTextureSize = 2 ** Math.ceil(Math.log2(Math.sqrt(MAX_BRICK_COUNT)));
        brickRenderTargets[0] = new THREE.RenderTarget(brickTextureSize, brickTextureSize, { type: THREE.FloatType });
        let textureOption = brickRenderTargets[0].texture;
        textureOption.magFilter = textureOption.minFilter = THREE.NearestFilter;
        textureOption.wrapS = THREE.RepeatWrapping;
        brickRenderTargets[1] = brickRenderTargets[0].clone();

        const spawnIndex = uniform(0);
        const spawnPosition = uniform(vec4());
        const explosionPosition = uniform(new THREE.Vector3(0, 0, 0));
        const explosionActive = uniform(0);
        const explosionTime = uniform(0);

        function brick_proc(n) {
            const i = float().toVar();
            const d = vec4().toVar();
            i.assign(uv().x.add(uv().y.mul(brickRenderTargets[0].width)).mul(brickRenderTargets[0].width).floor());
            If(explosionActive.equal(1).and(i.greaterThanEqual(spawnIndex)).and(i.lessThan(spawnIndex.add(10))), () => {
                const offset = i.sub(spawnIndex).mul(0.1);
                d.assign(vec4(
                    explosionPosition.x.add(sin(offset).mul(0.5)),
                    explosionPosition.y.add(cos(offset).mul(0.5)),
                    explosionPosition.z.add(offset),
                    time.mul(10).add(offset)
                ));
            }).Else(() => {
                d.assign(texture(brickRenderTargets[n].texture, uv()));
                const a = d.w.floor().mul(0.01 * 6.28318);
                d.xz.addAssign(vec2(cos(a), sin(a)).mul(d.y.mul(-0.01).add(0.05)));
                d.w.assign(d.w.fract().sub(1 / 120).max(0).add(d.w.floor()));
            });
            return d;
        }

        const brickMaterialWith0 = new THREE.NodeMaterial();
        const brickMaterialWith1 = brickMaterialWith0.clone();
        brickMaterialWith0.fragmentNode = Fn(() => brick_proc(0))();
        brickMaterialWith1.fragmentNode = Fn(() => brick_proc(1))();

        const brickMaterial = new THREE.MeshLambertNodeMaterial({ color: new THREE.Color(10, 0, 20) });
        brickMaterial.positionNode = Fn(() => {
            const i = float(instanceIndex);
            const p = vec3().toVar();
            const d = vec4().toVar();
            d.assign(texture(brickRenderTargets[0].texture, vec2(i, i.mul(1 / brickRenderTargets[0].width).floor()).add(0.5).mul(1 / brickRenderTargets[0].width)));
            p.assign(vec3(d.x, sin(d.w.fract().mul(3 * 3.14159)).abs().mul(d.y).mul(d.w.fract()), d.z));
            If(explosionActive.equal(1).and(i.greaterThanEqual(spawnIndex)).and(i.lessThan(spawnIndex.add(10))), () => {
                const t = explosionTime.sub(d.w.fract()).mul(2);
                p.addAssign(vec3(
                    sin(i).mul(t),
                    cos(i).mul(t),
                    sin(i.add(1)).mul(t)
                ).mul(0.5));
                If(t.greaterThan(1), () => {
                    p.y.assign(-10);
                });
            });
            p.addAssign(positionLocal.mul(d.w.fract()));
            return p;
        })();

        const bricks = new THREE.InstancedMesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), brickMaterial, MAX_BRICK_COUNT);
        bricks.castShadow = true;
        bricks.frustumCulled = false;
        scene.add(bricks);

        const textureLoader = new THREE.TextureLoader();
        function createFloor() {
            const floorTexture = textureLoader.load(ext_resource_url + '/textures/floor.png');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(1, 1);
            const floorGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
            const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -1.57080;
            floor.receiveShadow = true;
            scene.add(floor);
        }
        createFloor();

        const pointLight = new THREE.PointLight(0xffcc66, 3, 100);
        pointLight.castShadow = true;
        pointLight.position.set(0, 1.4, 0);
        pointLight.layers.enable(LAYER_VOLUMETRIC_LIGHTING);
        scene.add(pointLight);
        pointLight.add(new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 6), new THREE.MeshBasicMaterial({
            color: 0xffffff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending
        })));

        const spotLight = new THREE.SpotLight(0xffffff, 100);
        spotLight.position.set(0, 9, -9);
        spotLight.target.position.set(0, 0.5 * 6, PENZ_POSITION);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 1;
        spotLight.decay = 2;
        spotLight.distance = 0;
        spotLight.map = textureLoader.load(ext_resource_url + "/image/colors_2.png");
        spotLight.castShadow = true;
        spotLight.layers.enable(LAYER_VOLUMETRIC_LIGHTING);
        scene.add(spotLight);
        scene.add(spotLight.target);
        spotLight.shadow.intensity = 0.98;
        spotLight.shadow.mapSize.width = spotLight.shadow.mapSize.height = 1024;
        spotLight.shadow.focus = 1;
        spotLight.shadow.bias = -0.003;
        spotLight.shadow.camera.near = 1;
        spotLight.shadow.camera.far = 25;

        const postProcessing = new THREE.PostProcessing(renderer);
        const scenePass = pass(scene, camera);
        volumeNodeMaterial.depthNode = scenePass.getTextureNode("depth").sample(screenUV);
        const volumeLightingLayers = new THREE.Layers();
        volumeLightingLayers.disableAll();
        volumeLightingLayers.enable(LAYER_VOLUMETRIC_LIGHTING);
        const volumetricPass = pass(scene, camera, { depthBuffer: false });
        volumetricPass.setLayers(volumeLightingLayers);
        const denoiseStrength = uniform(0.6);
        const blurredVolumetricPass = gaussianBlur(volumetricPass, denoiseStrength);

        const guiParams = { quality: 1, resolution: 0.1, denoise: true };
        const gui = new GUI();
        function setResolution() { volumetricPass.setResolution(guiParams.resolution); }
        const volumetricLightingIntensity = uniform(1);
        function setDenoise() {
            const d = guiParams.denoise ? blurredVolumetricPass : volumetricPass;
            postProcessing.outputNode = scenePass.add(d.mul(volumetricLightingIntensity));
            postProcessing.needsUpdate = true;
        }
        setResolution();
        setDenoise();

        let guiFolder = gui.addFolder("Ray Marching").close();
        guiFolder.add(guiParams, "resolution", 0.1, 0.5).name("Resolution").onChange(setResolution);
        guiFolder.add(volumeNodeMaterial, "steps", 2, 12).name("Step Count");
        guiFolder.add(denoiseStrength, "value", 0, 1).name("Denoise Strength");
        guiFolder.add(guiParams, "denoise").name("Denoise").onChange(setDenoise);

        guiFolder = gui.addFolder("Lighting / Scene").close();
        guiFolder.add(pointLight, "intensity", 0, 6).name("Point Light");
        guiFolder.add(spotLight, "intensity", 0, 200).name("Spot Light");
        guiFolder.add(volumetricLightingIntensity, "value", 0, 2).name("Fog Intensity");
        guiFolder.add(smokeAmount, "value", 0, 3).name("Smoke Amount");

        // Physics Setup
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.allowSleep = false;
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.defaultContactMaterial.friction = 0.5;
        world.defaultContactMaterial.restitution = 0.0;

        const BUILDING_COUNT = 10;
        const BUILDING_MIN_SIZE = 10;
        const BUILDING_MAX_HEIGHT = 20;
        const BRICK_HEIGHT = 2.0;
        const BRICK_WIDTH = 2.0;
        const BRICK_LENGTH = 6.0;

        let buildings = [];
        let buildingInstances = [];
        let buildingPhysicsBodies = [];
        let dynamicBricks = [];

        function initBuildings() {
            const obstacleTexture = textureLoader.load(ext_resource_url + '/textures/obstacle.png');
            obstacleTexture.wrapS = THREE.RepeatWrapping;
            obstacleTexture.wrapT = THREE.RepeatWrapping;
            obstacleTexture.repeat.set(1, 1);
            const brickGeometry = new THREE.BoxGeometry(BRICK_LENGTH, BRICK_HEIGHT, BRICK_WIDTH);
            const brickMaterial = new THREE.MeshStandardMaterial({ map: obstacleTexture });

            const groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                position: new CANNON.Vec3(0, 0, 0),
                material: new CANNON.Material("groundMaterial")
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            const brickMaterialPhysics = new CANNON.Material("brickMaterial");
            const brickGroundContact = new CANNON.ContactMaterial(groundBody.material, brickMaterialPhysics, {
                friction: 0.5,
                restitution: 0.0
            });
            const brickBrickContact = new CANNON.ContactMaterial(brickMaterialPhysics, brickMaterialPhysics, {
                friction: 0.5,
                restitution: 0.0
            });
            world.addContactMaterial(brickGroundContact);
            world.addContactMaterial(brickBrickContact);

            buildings = [];
            buildingInstances = [];
            buildingPhysicsBodies = [];
            dynamicBricks = [];

            for (let i = 0; i < BUILDING_COUNT; i++) {
                const height = Math.floor(Math.random() * (BUILDING_MAX_HEIGHT - BUILDING_MIN_SIZE + 1)) + BUILDING_MIN_SIZE;
                const buildingBricks = [];
                const baseX = (Math.random() - 0.5) * GROUND_SIZE * 0.8;
                const baseZ = (Math.random() - 0.5) * GROUND_SIZE * 0.8;

                const bricksPerLayer = 3;
                const totalBricks = height * bricksPerLayer;

                const instancedMesh = new THREE.InstancedMesh(brickGeometry, brickMaterial, totalBricks);
                instancedMesh.castShadow = true;
                instancedMesh.receiveShadow = true;
                scene.add(instancedMesh);

                const compoundBody = new CANNON.Body({
                    mass: 0,
                    position: new CANNON.Vec3(baseX, 0, baseZ),
                    material: brickMaterialPhysics
                });

                let instanceIndex = 0;
                for (let y = 0; y < height; y++) {
                    const isEvenLayer = y % 2 === 0;
                    for (let j = 0; j < bricksPerLayer; j++) {
                        let posX, posY, posZ, rotationY;
                        if (isEvenLayer) {
                            posX = baseX;
                            posY = y * BRICK_HEIGHT + BRICK_HEIGHT / 2;
                            posZ = baseZ + (j - 1) * BRICK_WIDTH;
                            rotationY = 0;
                        } else {
                            posX = baseX + (j - 1) * BRICK_WIDTH;
                            posY = y * BRICK_HEIGHT + BRICK_HEIGHT / 2;
                            posZ = baseZ;
                            rotationY = Math.PI / 2;
                        }

                        const matrix = new THREE.Matrix4();
                        matrix.makeRotationY(rotationY);
                        matrix.setPosition(posX, posY, posZ);
                        instancedMesh.setMatrixAt(instanceIndex, matrix);

                        const brickShape = new CANNON.Box(new CANNON.Vec3(BRICK_LENGTH/2, BRICK_HEIGHT/2, BRICK_WIDTH/2));
                        const shapeOffset = new CANNON.Vec3(posX - baseX, posY, posZ - baseZ);
                        const shapeOrientation = new CANNON.Quaternion();
                        shapeOrientation.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
                        compoundBody.addShape(brickShape, shapeOffset, shapeOrientation);

                        buildingBricks.push({
                            instanceId: instanceIndex,
                            position: new THREE.Vector3(posX, posY, posZ),
                            rotationY: rotationY,
                            active: true
                        });
                        instanceIndex++;
                    }
                }

                world.addBody(compoundBody);
                instancedMesh.instanceMatrix.needsUpdate = true;
                buildings.push(buildingBricks);
                buildingInstances.push(instancedMesh);
                buildingPhysicsBodies.push(compoundBody);
            }
        }

        function decomposeBuilding(buildingIndex, hitBrickIndex) {
            const building = buildings[buildingIndex];
            const instancedMesh = buildingInstances[buildingIndex];
            const compoundBody = buildingPhysicsBodies[buildingIndex];

            world.removeBody(compoundBody);

            const remainingBricks = [];
            building.forEach((brick, index) => {
                if (!brick.active || index === hitBrickIndex) return;

                const brickBody = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Box(new CANNON.Vec3(BRICK_LENGTH/2, BRICK_HEIGHT/2, BRICK_WIDTH/2)),
                    position: new CANNON.Vec3(brick.position.x, brick.position.y, brick.position.z),
                    material: compoundBody.material,
                    linearDamping: 0.1,
                    angularDamping: 0.1
                });
                brickBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), brick.rotationY);
                brickBody.allowSleep = false;
                brickBody.sleepSpeedLimit = 0.1;
                brickBody.sleepTimeLimit = 0.5;
                world.addBody(brickBody);

                const brickMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(BRICK_LENGTH, BRICK_HEIGHT, BRICK_WIDTH),
                    new THREE.MeshLambertMaterial({ color: 0x888888, visible: false })
                );
                brickMesh.position.copy(brick.position);
                brickMesh.rotation.y = brick.rotationY;
                scene.add(brickMesh);

                remainingBricks.push({
                    instanceId: brick.instanceId,
                    physicsBody: brickBody,
                    detectionMesh: brickMesh,
                    active: true
                });
            });

            buildings[buildingIndex] = remainingBricks;
            buildingPhysicsBodies[buildingIndex] = null;
            dynamicBricks = dynamicBricks.concat(remainingBricks);
        }

        function checkBeamCollision(beam) {
            const raycaster = new THREE.Raycaster();
            const origin = beam.position.clone();
            const direction = new THREE.Vector3();
            beam.getWorldDirection(direction);
            raycaster.set(origin, direction);

            let explosionTriggered = false;
            let hitBuildingIndex = -1;
            let hitBrickIndex = -1;

            for (let i = 0; i < buildingInstances.length; i++) {
                if (buildingPhysicsBodies[i] === null) continue;
                const intersects = raycaster.intersectObject(buildingInstances[i]);
                if (intersects.length > 0) {
                    const instanceId = intersects[0].instanceId;
                    const building = buildings[i];
                    hitBrickIndex = building.findIndex(brick => brick.instanceId === instanceId && brick.active);
                    if (hitBrickIndex !== -1) {
                        hitBuildingIndex = i;
                        break;
                    }
                }
            }

            if (hitBuildingIndex === -1) {
                const intersects = raycaster.intersectObjects(dynamicBricks.map(brick => brick.detectionMesh));
                if (intersects.length > 0) {
                    const hitMesh = intersects[0].object;
                    for (let i = 0; i < buildings.length; i++) {
                        const building = buildings[i];
                        hitBrickIndex = building.findIndex(brick => brick.detectionMesh === hitMesh && brick.active);
                        if (hitBrickIndex !== -1) {
                            hitBuildingIndex = i;
                            break;
                        }
                    }
                }
            }

            if (hitBuildingIndex !== -1 && hitBrickIndex !== -1) {
                const building = buildings[hitBuildingIndex];
                const hitBrick = building[hitBrickIndex];
                const hitPoint = hitBrick.detectionMesh ? hitBrick.detectionMesh.position : hitBrick.position;

                hitBrick.active = false;
                const instancedMesh = buildingInstances[hitBuildingIndex];
                const dummy = new THREE.Object3D();
                dummy.position.set(0, -1000, 0);
                const matrix = new THREE.Matrix4();
                matrix.compose(dummy.position, dummy.quaternion, dummy.scale);
                instancedMesh.setMatrixAt(hitBrick.instanceId, matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;

                if (hitBrick.detectionMesh) {
                    scene.remove(hitBrick.detectionMesh);
                    dynamicBricks = dynamicBricks.filter(brick => brick.detectionMesh !== hitBrick.detectionMesh);
                }
                if (hitBrick.physicsBody) {
                    world.removeBody(hitBrick.physicsBody);
                }

                if (buildingPhysicsBodies[hitBuildingIndex] !== null) {
                    decomposeBuilding(hitBuildingIndex, hitBrickIndex);
                }

                explosionPosition.value.set(hitPoint.x, hitPoint.y, hitPoint.z);
                explosionActive.value = 1;
                explosionTime.value = performance.now() / 1000;
                spawnIndex.value = (spawnIndex.value + 2) % MAX_BRICK_COUNT;
                explosionTriggered = true;
            }
            return explosionTriggered;
        }

        // Input Handling
        function setupEventListeners() {
            const cameraButtons = document.querySelectorAll('#camera-buttons button');
            cameraButtons.forEach(button => {
                button.addEventListener('click', () => {
                    switchCamera(button.dataset.camera);
                });
            });

            const keyDownHandler = (e) => {
                const key = e.key.toLowerCase();
                if (key === ' ') inputKeys.space = true;
                else if (key === 'shift') inputKeys.shift = true;
                else if (inputKeys.hasOwnProperty(key)) inputKeys[key] = true;

                if (key === '1') switchCamera('perspective');
                else if (key === '2') switchCamera('firstPerson');
                else if (key === '3') switchCamera('topDown');
            };

            const keyUpHandler = (e) => {
                const key = e.key.toLowerCase();
                if (key === ' ') inputKeys.space = false;
                else if (key === 'shift') inputKeys.shift = false;
                else if (inputKeys.hasOwnProperty(key)) inputKeys[key] = false;
            };

            const mouseMoveHandler = (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                inputKeys.mouseMovementX = e.movementX || 0;
                inputKeys.mouseMovementY = e.movementY || 0;
            };

            const mouseDownHandler = (e) => {
                if (e.button === 0) inputKeys.mouseLeft = true;
            };

            const mouseUpHandler = (e) => {
                if (e.button === 0) inputKeys.mouseLeft = false;
            };

            window.addEventListener('keydown', keyDownHandler);
            window.addEventListener('keyup', keyUpHandler);
            window.addEventListener('mousemove', mouseMoveHandler);
            window.addEventListener('mousedown', mouseDownHandler);
            window.addEventListener('mouseup', mouseUpHandler);

            const joystickContainer = document.getElementById('joystick-container');
            const joystick = document.getElementById('joystick');
            let joystickActive = false;
            let joystickPointerId = null;

            function handleJoystickStart(event) {
                event.preventDefault();
                const touch = event.changedTouches[0];
                joystickActive = true;
                joystickPointerId = touch.identifier;
                updateJoystick(touch);
            }

            function handleJoystickMove(event) {
                event.preventDefault();
                if (!joystickActive) return;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    if (touch.identifier === joystickPointerId) {
                        updateJoystick(touch);
                        break;
                    }
                }
            }

            function handleJoystickEnd(event) {
                event.preventDefault();
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === joystickPointerId) {
                        joystickActive = false;
                        joystickPointerId = null;
                        resetJoystick();
                        break;
                    }
                }
            }

            function updateJoystick(touch) {
                const rect = joystickContainer.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const deltaX = x - centerX;
                const deltaY = y - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2;

                let joystickX = deltaX / maxDistance;
                let joystickY = deltaY / maxDistance;
                joystickX = Math.max(-1, Math.min(1, joystickX));
                joystickY = Math.max(-1, Math.min(1, joystickY));

                inputKeys.joystick.x = joystickX;
                inputKeys.joystick.y = joystickY;

                const joystickXPos = centerX + joystickX * maxDistance;
                const joystickYPos = centerY + joystickY * maxDistance;
                joystick.style.left = `${joystickXPos}px`;
                joystick.style.top = `${joystickYPos}px`;
            }

            function resetJoystick() {
                joystick.style.left = '50%';
                joystick.style.top = '50%';
                inputKeys.joystick.x = 0;
                inputKeys.joystick.y = 0;
            }

            joystickContainer.addEventListener('touchstart', handleJoystickStart);
            joystickContainer.addEventListener('touchmove', handleJoystickMove);
            joystickContainer.addEventListener('touchend', handleJoystickEnd);
            joystickContainer.addEventListener('touchcancel', handleJoystickEnd);
        }

        function switchCamera(mode) {
            cameraMode = mode;
            if (mode === 'perspective') {
                orbitControls.enabled = true;
                orbitControls.target.copy(penguin ? penguin.position : new THREE.Vector3(0, 0, PENZ_POSITION));
                camera.position.set(-8, 5, 9);
                camera.lookAt(orbitControls.target);
            } else if (mode === 'firstPerson') {
                orbitControls.enabled = false;
                camera.rotation.x = 0;
                camera.rotation.z = 0;
            } else if (mode === 'topDown') {
                orbitControls.enabled = false;
                camera.rotation.x = -Math.PI / 2;
            }
            console.log(`Switched to ${mode} Camera`);
        }

        function getShortestAngleDifference(currentAngle, targetAngle) {
            let delta = targetAngle - currentAngle;
            delta = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;
            return delta;
        }

        function updatePenguin(delta) {
            if (!penguin) return;

            const moveDirection = new THREE.Vector3();
            let isMoving = false;

            if (cameraMode === 'firstPerson') {
                if (inputKeys.joystick.y !== 0) {
                    const forwardDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(penguin.quaternion).normalize();
                    moveDirection.add(forwardDirection.multiplyScalar(-inputKeys.joystick.y));
                }
                if (inputKeys.joystick.x !== 0) {
                    penguin.rotation.y -= inputKeys.joystick.x * ROTATION_SPEED * delta;
                }
                if (inputKeys.w) moveDirection.add(new THREE.Vector3(0, 0, 1).applyQuaternion(penguin.quaternion));
                if (inputKeys.s) moveDirection.sub(new THREE.Vector3(0, 0, 1).applyQuaternion(penguin.quaternion));

                if (inputKeys.shift || inputKeys.mouseLeft) {
                    if (inputKeys.a) moveDirection.add(new THREE.Vector3(1, 0, 0).applyQuaternion(penguin.quaternion));
                    if (inputKeys.d) moveDirection.sub(new THREE.Vector3(1, 0, 0).applyQuaternion(penguin.quaternion));
                } else {
                    if (inputKeys.a) penguin.rotation.y += ROTATION_SPEED * delta;
                    if (inputKeys.d) penguin.rotation.y -= ROTATION_SPEED * delta;
                }
                
                //if (inputKeys.a) penguin.rotation.y += ROTATION_SPEED * delta;
                //if (inputKeys.d) penguin.rotation.y -= ROTATION_SPEED * delta;
                
                if (inputKeys.mouseLeft) {
                    let mv = inputKeys.mouseMovementX;
                    if (mv > 32) mv = 32;
                    if (mv < -32) mv = -32;
                    penguin.rotation.y -= mv * 0.01;
                }
            } else {
                const forward = new THREE.Vector3();
                const left = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                left.copy(forward).applyAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2).normalize();

                if (inputKeys.w) moveDirection.add(forward);
                if (inputKeys.s) moveDirection.sub(forward);
                if (inputKeys.a) moveDirection.sub(left);
                if (inputKeys.d) moveDirection.add(left);

                if (inputKeys.joystick.x !== 0 || inputKeys.joystick.y !== 0) {
                    const joystickDirection = new THREE.Vector3(inputKeys.joystick.x, 0, -inputKeys.joystick.y).normalize();
                    moveDirection.add(left.clone().multiplyScalar(joystickDirection.x));
                    moveDirection.add(forward.clone().multiplyScalar(joystickDirection.z));
                }

                if (moveDirection.lengthSq() > 0) {
                    const angle = Math.atan2(moveDirection.x, moveDirection.z);
                    const deltaAngle = getShortestAngleDifference(penguin.rotation.y, angle);
                    penguin.rotation.y += deltaAngle * ROTATION_SPEED * delta;
                }
            }

            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize();
                penguin.position.addScaledVector(moveDirection, MOVE_SPEED * delta);
                isMoving = true;
            }

            if (cameraMode === 'firstPerson') {
                camera.position.copy(penguin.position);
                camera.position.y += 2;
                camera.rotation.y = penguin.rotation.y + Math.PI;
            } else if (cameraMode === 'topDown') {
                camera.position.set(penguin.position.x, 50, penguin.position.z);
                camera.lookAt(penguin.position);
            } else {
                orbitControls.target.copy(penguin.position);
                orbitControls.update();
            }

            // Update beams and neck
            const timeValue = 0.001 * performance.now();
            const cosRotation = Math.cos(-penguin.rotation.y);
            const sinRotation = Math.sin(-penguin.rotation.y);
            const beamBaseX = 0;
            const beamBaseZ = 6;
            const targetX = penguin.position.x + (beamBaseX * cosRotation - beamBaseZ * sinRotation);
            const targetZ = penguin.position.z + (beamBaseX * sinRotation + beamBaseZ * cosRotation);
            const aim = new THREE.Vector2(
                targetX + 1 * Math.cos(0.7 * timeValue * 8),
                targetZ + 1 * Math.sin(0.45 * timeValue * 8)
            );

            pointLight.position.set(aim.x, 0.1 + 0.5 * Math.random(), aim.y);

            let neckAngle = Math.atan2(aim.x - penguin.position.x, aim.y - penguin.position.z) -penguin.rotation.y;
            neckRoot.rotation.y = neckAngle;

            let aimDistance = Math.sqrt(
                (aim.x - penguin.position.x) * (aim.x - penguin.position.x) +
                (aim.y - penguin.position.z) * (aim.y - penguin.position.z)
            );

            const baseScale = 0.5;
            const beamBasePositionRight = new THREE.Vector3(
                baseScale * (2.5 * Math.sin(neckAngle - 0.4)),
                baseScale * (6.7 + 0.1 * aimDistance),
                baseScale * (2.5 * Math.cos(neckAngle - 0.4))
            );
            const beamBasePositionLeft = new THREE.Vector3(
                baseScale * (2.5 * Math.sin(neckAngle + 0.4)),
                baseScale * (6.7 + 0.1 * aimDistance),
                baseScale * (2.5 * Math.cos(neckAngle + 0.4))
            );

            beamRed.position.set(
                penguin.position.x + (beamBasePositionRight.x * cosRotation - beamBasePositionRight.z * sinRotation),
                beamBasePositionRight.y,
                penguin.position.z + (beamBasePositionRight.x * sinRotation + beamBasePositionRight.z * cosRotation)
            );
            beamRed.up.copy(camera.position);
            beamRed.lookAt(aim.x, 0, aim.y);

            beamBlue.position.set(
                penguin.position.x + (beamBasePositionLeft.x * cosRotation - beamBasePositionLeft.z * sinRotation),
                beamBasePositionLeft.y,
                penguin.position.z + (beamBasePositionLeft.x * sinRotation + beamBasePositionLeft.z * cosRotation)
            );
            beamBlue.up.copy(camera.position);
            beamBlue.lookAt(aim.x, 0, aim.y);

            const armRotation = Math.sin(15 * timeValue);
            leftArm.rotation.z = 0.5 * armRotation;
            rightArm.rotation.z = -0.5 * armRotation;
            beak.rotation.x = 0.25 + 0.2 * armRotation;
            neckMid.rotation.x = neckEnd.rotation.x = 1.1 - 0.04 * aimDistance;
        }

        function tick() {
            if (!penguin) return;

            const delta = 0.016;
            const timeValue = 0.001 * performance.now();

            world.step(delta);

            buildings.forEach((building, buildingIndex) => {
                const instancedMesh = buildingInstances[buildingIndex];
                if (buildingPhysicsBodies[buildingIndex] !== null) return;
                building.forEach(brick => {
                    if (!brick.active || !brick.physicsBody) return;
                    const body = brick.physicsBody;
                    const position = new THREE.Vector3(body.position.x, body.position.y, body.position.z);
                    const quaternion = new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);
                    const matrix = new THREE.Matrix4();
                    matrix.compose(position, quaternion, new THREE.Vector3(1, 1, 1));
                    instancedMesh.setMatrixAt(brick.instanceId, matrix);
                    if (brick.detectionMesh) {
                        brick.detectionMesh.position.copy(position);
                        brick.detectionMesh.quaternion.copy(quaternion);
                    }
                });
                instancedMesh.instanceMatrix.needsUpdate = true;
            });

            updatePenguin(delta);

            orthographicPlane.material = (brickRenderTargetIndex < 0.5) ? brickMaterialWith0 : brickMaterialWith1;
            brickRenderTargetIndex = 1 - brickRenderTargetIndex;
            renderer.setRenderTarget(brickRenderTargets[brickRenderTargetIndex]);
            renderer.render(orthographicScene, orthographicCamera);
            renderer.setRenderTarget(null);

            shotHalf.value = 0.25 + 0.25 * Math.sin(timeValue);
            const redHit = checkBeamCollision(beamRed);
            const blueHit = checkBeamCollision(beamBlue);
            if (explosionActive.value === 1 && (performance.now() / 1000 - explosionTime.value) > 1) {
                explosionActive.value = 0;
            }

            postProcessing.render();
            stats.update();
        }

        // Initialization
        setupEventListeners();
        initBuildings();
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>